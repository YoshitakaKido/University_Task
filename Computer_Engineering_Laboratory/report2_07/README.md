# report2_07 - Elective subject -

## 課題内容 - Contents  

* コピー対象の領域の重なり具合が、report2_05とreport2_06のどちらの場合であっても、コピー方法を自動的に切り替えて、正しくコピーできるプログラムを作成せよ。  
* 完成したプログラムが正しく動作することを示すため、両方(report2_05, report2_06)のデータ領域に対する実行結果を明記すること

## C言語版プログラムのリスト
```c
#include <stdio.h>
#include <stdlib.h>

int array[15] = {0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int array2[15] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0};

int B5(){
	int * const from = array + 5;
    int * const to = array;
    int * p;
    for(p = array; p < array + 15; p++)
        printf("%p : %d\n", p, *p);
    printf("\n");
    for(p = array; p < array + 10; p++)
        *p = p[from - to];
    for(p = array; p < array + 15; p++)
        printf("%p : %d\n", p, *p);
	printf("\n");
}

int B6(){
	int * const from = array2;
	int * const to = array2 + 5;
	int * p;
	for(p = array2; p < array2 + 15; p++ )
		printf("%p : %d\n", p, *p);
	for(p = array2 + 15; p >= array2 + 5; p--)
		*p = p[from - to];
	printf("\n");
	for(p = array2; p < array2 + 15; p++)
		printf("%p : %d\n", p, *p);
}

int main(){

	int * from = array + 5;
	int * to = array;

	if(from > to){
		B5();
	}
	else
		B6();

	int * from_2 = array2;
	int * to_2 = array2 + 5;

	if(from_2 > to_2)
		B5();
	else
		B6();

	return 0;
}
```

## 完成したプログラムのリスト
```s
        .data                       # データセグメントにデータを配置することを示す

to_5:   .word   0, 0, 0, 0, 0
from_5: .word   1, 2, 3, 4, 5
        .word   6, 7, 8, 9, 10

from_6: .word   1, 2, 3, 4, 5
to_6:   .word   6, 7, 8, 9, 10
        .word   0, 0, 0, 0, 0

str:    .asciiz "\n"
msg:    .asciiz ":"
        .text                       # 以下の記述をテキストセグメントに配置
        .align  2                   # 4byte境界になるように調整する
        .globl  main
main:
        la        $t0, from_5       # from_5が指すアドレスをレジスタ$t0に格納
        la        $t1, to_5         # to_5が指すアドレスをレジスタ$t1に格納
        bgt       $t0, $t1, main5   # $t0 > $t1ならばラベルmain5へ
        bgt       $t1, $t0, main6   # $t1 > $t0ならばラベルmain6へ
main5:
        la        $t0, to_5         # toが指すアドレスをレジスタ t0 に格納
        la        $t1, from_5       # fromが指すアドレスをレジスタ t1 に格納
        la        $t2, to_5         # toが指すアドレスをレジスタ t2 に格納
        li        $t3, 15           # レジスタ t3 に即値15をロード
        li        $t4, 10           # レジスタ t4 に即値10をロード
        li        $t5, 15           # レジスタ t5 に即値15をロード
loop5_1:
        move      $a0, $t0          # レジスタ a0 に レジスタ t0 の保持するアドレスを格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ to のアドレスを表示
        la        $a0, msg          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 文字列 ":" を表示
        lw        $a0, 0($t0)       # $t0 + 0のアドレスの内容をレジスタ a0 に格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ a0 の内容を表示
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addu      $t0, $t0, 4       # レジスタ t0 の保持するアドレスに 4 を加えたものをレジスタ t0 に格納
        subu      $t3, $t3, 1       # レジスタ t3 の保持する値から 1 を引いたものをレジスタ t3 に格納
        bne       $t3, $0, loop5_1  # レジスタ t3 の保持する値が 0 でなければラベル loop へ
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
loop5_2:
        lw        $t6, 0($t1)       # $t1 + 0のアドレスの内容をレジスタ t6 に格納
        sw        $t6, 0($t2)       # $t2 + 0 が示すメモリ番地にレジスタ t6 の内容を1ワードとして格納
        addu      $t1, $t1, 4       # レジスタ t1 の保持するアドレスに 4 を加えたものをレジスタ t1 に格納
        addu      $t2, $t2, 4       # レジスタ t2 の保持するアドレスに 4 を加えたものをレジスタ t2 に格納
        subu      $t4, $t4, 1       # レジスタ t4 の保持する値から 1 引いたものをレジスタ t4 に格納
        bne       $t4, $0, loop5_2  # レジスタ t4 の保持する値が 0 でなければラベル loo2 へ
        subu      $t2, $t2, 40      # レジスタ t2 の保持するアドレスから 40 を引いたものをレジスタ t2 に格納
loop5_3:
        move      $a0, $t2          # レジスタ a0 にレジスタ t2 の保持するアドレスを格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ t2 の保持するアドレスを表示
        la        $a0, msg          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 文字列 ":" を表示
        lw        $a0, 0($t2)       # $t2 + 0のアドレスの内容をレジスタ a0 に格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ a0 の内容を表示
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addu      $t2, $t2, 4       # レジスタ t2 の保持するアドレスに 4 を加えたものをレジスタ t2 に格納
        subu      $t5, $t5, 1       # レジスタ t5 の保持する値から 1 を引いたものをレジスタ t5 に格納
        bne       $t5, $0, loop5_3  # レジスタ t5 の保持する値が 0 でなければラベル loop3 へ
        li        $t0, 0            # レジスタ$t0に即値０を格納
        li        $t1, 2            # レジスタ$t1に即値２を格納
        addi      $t0, $t0, 1       # レジスタ$t0に１を加算
        bne       $t0, $t1, main6   # $t0 != $t1ならばラベルmain6へ
        j         $ra
main6:
        la        $t1, from_6       # fromが指すアドレスをレジスタ t1 に格納
        la        $t2, to_6         # toが指すアドレスをレジスタ t2 に格納
        bgt       $t1, $t2, main5   # $t1 > $t2ならばラベルmain5へ
        li        $t3, 15           # レジスタ $t3 に即値15をロード
        li        $t4, 10           # レジスタ $t4 に即値10をロード
        li        $t5, 15           # レジスタ $t5 に即値15をロード
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行表示
loop:
        move      $a0, $t1          # レジスタ a0 に レジスタ t1 の保持するアドレスを格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ to のアドレスを表示
        la        $a0, msg          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 文字列 ":" を表示
        lw        $a0, 0($t1)       # $t1 + 0のアドレスの内容をレジスタ a0 に格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ a0 の内容を表示
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addu      $t1, $t1, 4       # レジスタ t1 の保持するアドレスに 4 を加えたものをレジスタ t1 に格納
        subu      $t3, $t3, 1       # レジスタ t3 の保持する値から 1 を引いたものをレジスタ t3 に格納
        bne       $t3, $0, loop     # レジスタ t3 の保持する値が 0 でなければラベル loop へ
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addi      $t1, $t1, -24     # レジスタ $t1 の保持するアドレスに -24 を加えたものをレジスタ $t1 に格納
        addu      $t2, $t2, 36      # レジスタ $t2 の保持するアドレスに 36 を加えたものをレジスタ $t2 に格納
loop2:
        lw        $t0, 0($t1)       # $t1 + 0のアドレスの内容をレジスタ t6 に格納
        sw        $t0, 0($t2)       # $t2 + 0 が示すメモリ番地にレジスタ t6 の内容を1ワードとして格納
        addi      $t1, $t1, -4      # レジスタ $t1 の保持するアドレスから 4 を引いたものをレジスタ $t1 に格納
        addi      $t2, $t2, -4      # レジスタ $t2 の保持するアドレスから 4 を引いたものをレジスタ $t2 に格納
        subu      $t4, $t4, 1       # レジスタ $t4 の保持する値から 1 引いたものをレジスタ $t4 に格納
        bne       $t4, $0, loop2    # レジスタ $t4 の保持する値が 0 でなければラベル loo2 へ
        addi      $t1, $t1, 4       # レジスタ $t1 の保持するアドレスに 4 を加えたものをレジスタ $t1 に格納
loop3:
        move      $a0, $t1          # レジスタ a0 にレジスタ $t2 の保持するアドレスを格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ t2 の保持するアドレスを表示
        la        $a0, msg          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 文字列 ":" を表示
        lw        $a0, 0($t1)       # $t2 + 0のアドレスの内容をレジスタ a0 に格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ a0 の内容を表示
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addu      $t1, $t1, 4       # レジスタ t2 の保持するアドレスに 4 を加えたものをレジスタ t2 に格納
        subu      $t5, $t5, 1       # レジスタ t5 の保持する値から 1 を引いたものをレジスタ t5 に格納
        bne       $t5, $0, loop3    # レジスタ t5 の保持する値が 0 でなければラベル loop3 へ
        j         $ra               # jump to $ra
```
## プログラムの説明
```txt
演習B5とB6のコードを主に再使用している為、大きく変更している部分のみ説明する。
まず演習B5においてのラベルがmain → main5、loop → loop5_1、loop2 → loop5_2、loop3 → loop5_3となった。
演習B6においてはラベルmainがmain6となっただけである。
今回新しくラベルmainが作成され、main内では
1行目でfrom_5が指すアドレスをレジスタ$t0に格納している。
2行目でto_5が指すアドレスをレジスタ$t1に格納している。
3行目でfrom_5とto_5のアドレスの大小を比較している。from_5の方が大きい場合はラベルmain5へ
4行目でもfrom_5とto_5のアドレスの大小を比較している。to_5の方が大きいい場合はラベルmain6へ
main5からは演習B5の説明と変化はない。
ただし、loop5_3内の16行目から変更点が存在する。
16行目でレジスタ$t0に即値０を格納している。
17行目ではレジスタ$t1に即値２を格納している。
18行目でレジスタ$t0に１を加算。
19行目でレジスタ$t0と$t1の値を比較し異なる場合はラベルmain6へ
上記の動作は今回の演習で実行結果の確認を２回(B5とB6)表示しなければならなかったため書き加えた。
またmain6内では
3行目でfrom_6とto_6のアドレスを比較し、from6の方が大きい場合はラベルmain5へ跳ぶことになっている。
以上より演習B5とB6のどちらでも自動的に判断して表示するプログラムが実装できた。
```
## 実行結果、および、その実行結果の正しさの説明
```txt
0x100402020 : 0
0x100402024 : 0
0x100402028 : 0
0x10040202c : 0
0x100402030 : 0
0x100402034 : 1
0x100402038 : 2
0x10040203c : 3
0x100402040 : 4
0x100402044 : 5
0x100402048 : 6
0x10040204c : 7
0x100402050 : 8
0x100402054 : 9
0x100402058 : 10

0x100402020 : 1
0x100402024 : 2
0x100402028 : 3
0x10040202c : 4
0x100402030 : 5
0x100402034 : 6
0x100402038 : 7
0x10040203c : 8
0x100402040 : 9
0x100402044 : 10
0x100402048 : 6
0x10040204c : 7
0x100402050 : 8
0x100402054 : 9
0x100402058 : 10

0x100402060 : 1
0x100402064 : 2
0x100402068 : 3
0x10040206c : 4
0x100402070 : 5
0x100402074 : 6
0x100402078 : 7
0x10040207c : 8
0x100402080 : 9
0x100402084 : 10
0x100402088 : 0
0x10040208c : 0
0x100402090 : 0
0x100402094 : 0
0x100402098 : 0

0x100402060 : 1
0x100402064 : 2
0x100402068 : 3
0x10040206c : 4
0x100402070 : 5
0x100402074 : 1
0x100402078 : 2
0x10040207c : 3
0x100402080 : 4
0x100402084 : 5
0x100402088 : 6
0x10040208c : 7
0x100402090 : 8
0x100402094 : 9
0x100402098 : 10
```
