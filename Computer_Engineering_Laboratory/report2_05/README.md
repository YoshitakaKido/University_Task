# report2_05 - Compulsory subject -

## 課題内容 - Contents  

* アドレス from から始まる10ワードのデータを、アドレス to から始まる10ワードの領域にコピーせよ  
* 領域の重なりに注意すること  
* また、正しく移動されたことを確認するために、コピー前後の15ワードの領域の内容を表示せよ  

## C言語版プログラムのリスト
```c
#include <stdio.h>
#include <stdlib.h>

int array[15] = {0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

int main(void){
    int * const from = array + 5;       //配列の5番目の要素のアドレスを格納     
    int * const to = array;             //配列の先頭要素のアドレスを格納
    int * p;                            //アドレスをコピーするためのポインタを宣言
    for(p = array; p < array + 15; p++) 
        printf("%p : %d\n", p, *p);
    printf("\n");
    for(p = array; p < array + 10; p++)
        *p = p[from - to];
    for(p = array; p < array + 15; p++)
        printf("%p : %d\n", p, *p);
    return 0;
}
```

## 完成したプログラムのリスト
```s
        .data                       # データセグメントにデータを配置することを示す
to:     .word   0, 0, 0, 0, 0
from:   .word   1, 2, 3, 4, 5
        .word   6, 7, 8, 9, 10
str:    .asciiz "\n"
msg:    .asciiz ":"
        .text                       # 以下の記述をテキストセグメントに配置
        .align  2                   # 4byte境界になるように調整する
        .globl  main
main:
        la        $t0, to           # toが指すアドレスをレジスタ t0 に格納
        la        $t1, from         # fromが指すアドレスをレジスタ t1 に格納
        la        $t2, to           # toが指すアドレスをレジスタ t2 に格納
        li        $t3, 15           # レジスタ t3 に即値15をロード
        li        $t4, 10           # レジスタ t4 に即値10をロード
        li        $t5, 15           # レジスタ t5 に即値15をロード
loop:
        move      $a0, $t0          # レジスタ a0 に レジスタ t0 の保持するアドレスを格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ to のアドレスを表示
        la        $a0, msg          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 文字列 ":" を表示
        lw        $a0, 0($t0)       # $t0 + 0のアドレスの内容をレジスタ a0 に格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ a0 の内容を表示
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addu      $t0, $t0, 4       # レジスタ t0 の保持するアドレスに 4 を加えたものをレジスタ t0 に格納
        subu      $t3, $t3, 1       # レジスタ t3 の保持する値から 1 を引いたものをレジスタ t3 に格納
        bne       $t3, $0, loop     # レジスタ t3 の保持する値が 0 でなければラベル loop へ
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
loop2:
        lw        $t6, 0($t1)       # $t1 + 0のアドレスの内容をレジスタ t6 に格納
        sw        $t6, 0($t2)       # $t2 + 0 が示すメモリ番地にレジスタ t6 の内容を1ワードとして格納
        addu      $t1, $t1, 4       # レジスタ t1 の保持するアドレスに 4 を加えたものをレジスタ t1 に格納
        addu      $t2, $t2, 4       # レジスタ t2 の保持するアドレスに 4 を加えたものをレジスタ t2 に格納
        subu      $t4, $t4, 1       # レジスタ t4 の保持する値から 1 引いたものをレジスタ t4 に格納
        bne       $t4, $0, loop2    # レジスタ t4 の保持する値が 0 でなければラベル loo2 へ
        subu      $t2, $t2, 40      # レジスタ t2 の保持するアドレスから 40 を引いたものをレジスタ t2 に格納
loop3:
        move      $a0, $t2          # レジスタ a0 にレジスタ t2 の保持するアドレスを格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ t2 の保持するアドレスを表示
        la        $a0, msg          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 文字列 ":" を表示
        lw        $a0, 0($t2)       # $t2 + 0のアドレスの内容をレジスタ a0 に格納
        li        $v0, 1            # print_intのシステムコールコードは 1
        syscall                     # レジスタ a0 の内容を表示
        la        $a0, str          # asciizで保存したプリントする文字列のアドレスをレジスタ a0 に格納
        li        $v0, 4            # print_stringのシステムコールコードは 4
        syscall                     # 改行処理
        addu      $t2, $t2, 4       # レジスタ t2 の保持するアドレスに 4 を加えたものをレジスタ t2 に格納
        subu      $t5, $t5, 1       # レジスタ t5 の保持する値から 1 を引いたものをレジスタ t5 に格納
        bne       $t5, $0, loop3    # レジスタ t5 の保持する値が 0 でなければラベル loop3 へ
        j         $ra               # jump to $ra
```

## プログラムの説明
```txt
ラベルmain内において、
1行目でtoが指すアドレスをレジスタ$t0に格納する。
2行目でfromが指すアドレスをレジスタ$t1に格納する。
3行目でtoが指すアドレスをレジスタ$t2に格納する。
4行目でレジスタ$t3に即値15をロードする。
5行目でレジスタ$t4に即値10をロードする。
6行目でレジスタ$t5に即値15をロードする。
上記の動作の後、ラベルloopに入る。ラベルloop以下では、
1行目でレジスタ$a0に レジスタ$t0の保持するアドレスを格納する。
2行目でsyscallでint型を表示する為にレジスタ$v0に1を格納する。
3行目でレジスタ$toのアドレスを表示する。
4行目でレジスタ$a0に文字列":"のアドレスを格納する。
5行目でsyscallでstring型を表示する為にレジスタ$v0に4を格納する。
6行目で文字列":"を表示する。
7行目で$t0 + 0のアドレスの内容をレジスタ$a0に格納する。
8行目でsyscallでint型を表示する為にレジスタ$v0に1を格納する。
9行目でレジスタ$a0の内容を表示する。
10行目でレジスタ$a0に改行を実行するための文字列"\n"のアドレスを格納する。
11行目でsyscallでstring型を表示する為にレジスタ$v0に4を格納する。
12行目で改行処理を実行する。
13行目で配列の要素はint型の為、次の要素を取り出すのに4バイト足し合わせる。
14行目で配列の全要素数に相当するレジスタ$t3から1を引く。
15行目で配列の要素を全部表示し終えているかどうかを評価する。表示し終えてなければラベルloopへ戻る
16行目でレジスタ$a0に改行を実行するための文字列"\n"のアドレスを格納する。
17行目でsyscallでstring型を表示する為にレジスタ$v0に4を格納する。
18行目で改行処理を実行する。
上記の動作の後、ラベルloop2へ入る。ラベルloop2以下では、
1行目でfromからのアドレスデータが入っているレジスタ$t1+0のアドレスをレジスタ$t6に格納する。
2行目でアドレスtoのアドレスデータが入っているレジスタ$t2に$t6のアドレスを格納する。
3行目でアドレスformから次の要素を取り出す為に4バイト足し合わせる。
4行目でアドレスtoから次の要素を代入する場所を参照する為に4バイト足し合わせる。
5行目でレジスタ$t4から1引いたものをレジスタ$t4に格納する。
レジスタ$t4はアドレスfromから10ワードのデータをコピーし終えたかどうかのカウンターの役割を果たす。
6行目で$t4が0と等しくないかどうか判断し、0でないのならばラベルloop2へ戻る。
7行目で初期状態のアドレスtoの先頭アドレスまで戻る為にレジスタ$t2から40を減算する。
上記の動作の後、ラベルloop3に入る。ラベルloop3以下では、
1行目でレジスタ$a0に レジスタ$t2の保持するアドレスを格納する。
2行目でsyscallでint型を表示する為にレジスタ$v0に1を格納する。
3行目でレジスタ$t2の保持するアドレスを表示する。
4行目でレジスタ$a0に文字列":"のアドレスを格納する。
5行目でsyscallでstring型を表示する為にレジスタ$v0に4を格納する。
6行目で文字列":"を表示する。
7行目で$t2 + 0のアドレスの内容をレジスタ$a0に格納する。
8行目でsyscallでint型を表示する為にレジスタ$v0に1を格納する。
9行目でレジスタ$a0の内容を表示。
10行目でレジスタ$a0に改行を実行するための文字列"\n"のアドレスを格納する。
11行目でsyscallでstring型を表示する為にレジスタ$v0に4を格納する。
12行目で改行処理を実行する。
13行目で配列の要素はint型の為、次の要素を取り出すのに4バイト足し合わせる。
14行目で配列の全要素数に相当するレジスタ$t3から1を引く。
15行目で配列の要素を全部表示し終えているかどうかを評価する。表示し終えてなければラベルloop3へ戻る
16行目で呼び出し側に戻る。
```

## 実行結果、および、その実行結果のせ正しさの説明
```txt
0x601060 : 0    アドレスtoの先頭アドレス
0x601064 : 0
0x601068 : 0
0x60106c : 0
0x601070 : 0
0x601074 : 1    アドレスfromの先頭アドレス
0x601078 : 2
0x60107c : 3
0x601080 : 4
0x601084 : 5
0x601088 : 6
0x60108c : 7
0x601090 : 8
0x601094 : 9
0x601098 : 10

0x601060 : 1
0x601064 : 2
0x601068 : 3
0x60106c : 4
0x601070 : 5
0x601074 : 6
0x601078 : 7
0x60107c : 8
0x601080 : 9
0x601084 : 10
0x601088 : 6
0x60108c : 7
0x601090 : 8
0x601094 : 9
0x601098 : 10
```
実行環境：  
* OS:Ubuntu14.04LTS  
* 実行結果の説明  
    上が初期状態であり、下がアドレスfromから始まる10ワードのでデータをアドレスtoから始まる10ワードの領域にコピーした結果である。  
    実行結果は期待通りアドレス from から始まる10ワードのデータを、アドレス to から始まる10ワードの領域にコピーできている。  
    よって実行結果は正しいことが示された。  
